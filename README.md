# identify-objects-with-Turtlebot

The objective of the work was to create an autonomous driving scheme for the TurtleBot platform locate and identify objects and return to its starting position. Each object will have an image embedded onto it belonging to a predefined library of images. The pipeline outputs the identification of each object. The development was completed in C++ and tested in the Gazebo environment. At a high level, the platform first performs the path planning to find the goal locations. Upon visiting each object in the plan, the image matching algorithm will be called to find the image ids.

## Overview

* First, the robot must complete a high-level path planning algorithm given the set of object coordinates. The ideal solution is an optimal algorithm that finds the path with the shortest distance efficiently. In practice, there is a tradeoff between the optimality and efficiency. The cheapest-link algorithm was selected for its efficiency in producing a solution. This algorithm travels the nodes choosing the cheapest path to ensure a continuous and complete path. In the final design, path planning is executed once upon initialization to reduce the computation time.

* Secondly, the robot must be able to compare images of objects in its environment to a given library and identify the matching image. The indirect method of identifying Speeded Up Robust Features (SURF) with OpenCV is used to find notable features descriptors in the scene and template images. The SURF method is a rotation and scale invariant feature detector and descriptor. Features are matched between the scene and the templates with a k-Nearest Neighbour approach based on a distance metric and filtered with the Lowe's ratio test and RANSAC. A homography matrix between potential matches is computed. A matching score for each template image was constructed with the match reprojection error, number of matches, and area and convexity of a transformed bounding box. (imagePipeline.cpp)

* Lastly, Adaptive Monte Carlo Localization (AMCL) was employed for localization and the ROS package move_base was used for navigation and obstacle avoidance. The particle filter approach to localization was chosen to avoid the error propagation present in dead reckoning. With the desired path computed, service calls and motion adjustements were made to ensure an obstacle free path when moving between objects. (navigation.cpp)
